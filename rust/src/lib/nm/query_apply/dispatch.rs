// SPDX-License-Identifier: Apache-2.0

use std::fmt::Write as _FmtWrite;
use std::io::{Read, Write};
use std::os::unix::fs::OpenOptionsExt;

use crate::{
    DispatchConfig, DispatchGlobalConfig, DispatchInterfaceType, ErrorKind,
    Interfaces, MergedDispatchGlobalConfig, MergedInterfaces, NmstateError,
};

const DEFAULT_DISPATCH_DIR: &str = "/etc/NetworkManager/dispatcher.d";

const SCRIPT_START_COMMENT: &str = "## NMSTATE DISPATCH SCRIPT START";
const SCRIPT_END_COMMENT: &str = "## NMSTATE DISPATCH SCRIPT END";
const SCRIPT_DISCLAMER: &str = "# GENERATED BY NMSTATE, DO NOT EDIT DIRECTLY";
const SCRIPT_VARIABLE_START: &str = "# SCRIPT_VARIABLE_START";
const SCRIPT_VARIABLE_END: &str = "# SCRIPT_VARIABLE_END";
const SCRIPT_ACTIVATION_START: &str = "# SCRIPT_ACTIVATION_START";
const SCRIPT_ACTIVATION_END: &str = "# SCRIPT_ACTIVATION_END";
const SCRIPT_DEACTIVATION_START: &str = "# SCRIPT_DEACTIVATION_START";
const SCRIPT_DEACTIVATION_END: &str = "# SCRIPT_DEACTIVATION_END";
const INDENT: &str = "    ";
const KERNEL_INDEX_GETTER: &str = "echo IFINDEX=$(";

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum NmAction {
    Up,
    Down,
}

impl std::fmt::Display for NmAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Up => "up",
                Self::Down => "down",
            }
        )
    }
}

pub(crate) fn apply_dispatch_script(
    merged_ifaces: &MergedInterfaces,
) -> Result<(), NmstateError> {
    for iface in merged_ifaces.kernel_ifaces.values().filter_map(|i| {
        if i.is_desired() {
            i.for_apply.as_ref()
        } else {
            None
        }
    }) {
        if iface.is_absent() {
            delete_dispatch_script(iface.name(), NmAction::Up)?;
            delete_dispatch_script(iface.name(), NmAction::Down)?;
        } else if let Some(dispatch_conf) = iface.base_iface().dispatch.as_ref()
        {
            let iface_name = iface.name();
            if let Some(post_up) = dispatch_conf.post_activation.as_deref() {
                if post_up.is_empty() {
                    delete_dispatch_script(iface_name, NmAction::Up)?;
                } else {
                    create_dispatch_script(iface_name, post_up, NmAction::Up)?;
                }
            }
            if let Some(post_down) = dispatch_conf.post_deactivation.as_deref()
            {
                if post_down.is_empty() {
                    delete_dispatch_script(iface_name, NmAction::Down)?;
                } else {
                    create_dispatch_script(
                        iface_name,
                        post_down,
                        NmAction::Down,
                    )?;
                }
            }
        }
    }
    Ok(())
}

fn create_dispatch_script(
    iface_name: &str,
    content: &str,
    nm_action: NmAction,
) -> Result<(), NmstateError> {
    let file_path = gen_file_path(iface_name, nm_action);
    let action_condition_line = match nm_action {
        NmAction::Up => r#"{ [ "$2" == "up" ] || [ "$2" == "reapply" ]; }"#,
        NmAction::Down => r#"[ "$2" == "down" ]"#,
    };

    let script_content = format!(
        r#"#!/usr/bin/bash
{SCRIPT_DISCLAMER}

if [ "$1" == "{iface_name}" ] && {action_condition_line}; then
{SCRIPT_START_COMMENT}
{content}
{SCRIPT_END_COMMENT}
fi
"#
    );

    if let Err(e) =
        write_execute_file(file_path.as_str(), script_content.as_str())
    {
        return Err(NmstateError::new(
            ErrorKind::InvalidArgument,
            format!(
                "Failed to create NetworkManager dispatch script \
                {file_path}: {e}"
            ),
        ));
    }

    Ok(())
}

fn write_execute_file(file_path: &str, content: &str) -> std::io::Result<()> {
    let mut fd = std::fs::OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .mode(0o744)
        .open(file_path)?;
    fd.write_all(content.as_bytes())?;
    Ok(())
}

/// Return HashMap with interface name as key and
/// (post_activation_script, post_deactivation_script) as value
pub(crate) fn fill_iface_dispatch_scripts(ifaces: &mut Interfaces) {
    let dir = std::env::var("NMSTATE_NM_DISPATCH_DIR")
        .unwrap_or(DEFAULT_DISPATCH_DIR.to_string());

    if let Ok(fd) = std::fs::read_dir(&dir) {
        for entry in fd.filter_map(Result::ok) {
            let file_name = if let Ok(s) = entry.file_name().into_string() {
                if s.starts_with("nmstate-") {
                    s
                } else {
                    continue;
                }
            } else {
                continue;
            };
            let file_path = format!("{dir}/{file_name}");
            let parts: Vec<&str> = file_name.split('-').collect();
            if parts.len() != 3 {
                continue;
            }
            let iface_name = parts[1];
            if !["up.sh", "down.sh"].contains(&parts[2]) {
                log::debug!("Got unknown dispatch action for {file_name}");
                continue;
            }
            let script_content =
                if let Some(s) = read_dispatch_script(&file_path) {
                    s
                } else {
                    continue;
                };
            if let Some(iface) = ifaces.kernel_ifaces.get_mut(iface_name) {
                match parts[2] {
                    "up.sh" => {
                        iface
                            .base_iface_mut()
                            .dispatch
                            .get_or_insert(DispatchConfig::default())
                            .post_activation = Some(script_content);
                    }
                    "down.sh" => {
                        iface
                            .base_iface_mut()
                            .dispatch
                            .get_or_insert(DispatchConfig::default())
                            .post_deactivation = Some(script_content);
                    }
                    // unreachable
                    _ => (),
                }
            }
        }
    }
}

fn read_dispatch_script(file_path: &str) -> Option<String> {
    if let Ok(mut fd) = std::fs::File::open(file_path) {
        let mut script_content: Vec<&str> = Vec::new();
        let mut content = String::new();
        fd.read_to_string(&mut content).ok();
        let mut begin = false;
        for line in content.split('\n') {
            if begin {
                if line == SCRIPT_END_COMMENT {
                    break;
                } else {
                    script_content.push(line);
                }
            } else if line == SCRIPT_START_COMMENT {
                begin = true;
                continue;
            }
        }
        if !script_content.is_empty() {
            return Some(script_content.join("\n"));
        }
    }
    None
}

fn delete_dispatch_script(
    iface_name: &str,
    nm_action: NmAction,
) -> Result<(), NmstateError> {
    let file_path = gen_file_path(iface_name, nm_action);
    let path = std::path::Path::new(&file_path);

    if path.exists() {
        if let Err(e) = std::fs::remove_file(path) {
            return Err(NmstateError::new(
                ErrorKind::PermissionError,
                format!(
                    "Failed to remove dispatch script {file_path}, error: {e}"
                ),
            ));
        }
    }
    Ok(())
}

fn gen_file_path(iface_name: &str, nm_action: NmAction) -> String {
    let dir = std::env::var("NMSTATE_NM_DISPATCH_DIR")
        .unwrap_or(DEFAULT_DISPATCH_DIR.to_string());

    format!("{dir}/nmstate-{iface_name}-{nm_action}.sh")
}

fn gen_generic_file_path(iface_type_name: &str) -> String {
    let dir = std::env::var("NMSTATE_NM_DISPATCH_DIR")
        .unwrap_or(DEFAULT_DISPATCH_DIR.to_string());

    let path = format!("{dir}/device");

    if !std::path::Path::new(&path).exists() {
        // follow up write action will fail with proper error
        std::fs::create_dir(&path).ok();
    }

    format!("{dir}/device/{iface_type_name}")
}

pub(crate) fn get_global_dispatch() -> Result<DispatchGlobalConfig, NmstateError>
{
    let mut ret = DispatchGlobalConfig::default();
    let dir = std::env::var("NMSTATE_NM_DISPATCH_DIR")
        .unwrap_or(DEFAULT_DISPATCH_DIR.to_string());
    let dir = format!("{dir}/device");

    if std::path::Path::new(&dir).is_dir() {
        match std::fs::read_dir(&dir) {
            Ok(fd) => {
                let mut iface_types = Vec::new();
                for entry in fd.filter_map(|fd| fd.ok()) {
                    let file_name =
                        if let Ok(s) = entry.file_name().into_string() {
                            s
                        } else {
                            continue;
                        };
                    let file_path = format!("{dir}/{file_name}");
                    if let Some(conf) =
                        get_dispatch_iface_type_conf(&file_name, &file_path)
                    {
                        iface_types.push(conf);
                    }
                }
                if !iface_types.is_empty() {
                    ret.interfaces = Some(iface_types);
                }
            }
            Err(e) => {
                log::info!("Failed to read {dir} {e}");
            }
        }
    }
    Ok(ret)
}

pub(crate) fn apply_dispatch_iface_type_scripts(
    dispatch: &MergedDispatchGlobalConfig,
) -> Result<(), NmstateError> {
    for (iface_type_name, conf) in dispatch.desired.iter() {
        let path = gen_generic_file_path(iface_type_name.as_str());
        if conf.is_absent() {
            log::info!("Removing dispatch interface type {}", conf.kind);
            let file_path = std::path::Path::new(&path);
            if file_path.exists() {
                std::fs::remove_file(&path).map_err(|e| {
                    NmstateError::new(
                        ErrorKind::PermissionError,
                        format!("Failed to remove file {path}: {e}"),
                    )
                })?
            };
        } else {
            let content = gen_nm_dispatch_iface_handler_script(conf);
            let mut fd = std::fs::OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .mode(0o744)
                .open(&path)
                .map_err(|e| {
                    NmstateError::new(
                        ErrorKind::PermissionError,
                        format!("Failed to write file {path}: {e}"),
                    )
                })?;
            fd.write_all(content.as_bytes()).map_err(|e| {
                NmstateError::new(
                    ErrorKind::PermissionError,
                    format!("Failed to write file {path}: {e}"),
                )
            })?;
        }
    }
    Ok(())
}

fn get_dispatch_iface_type_conf(
    file_name: &str,
    file_path: &str,
) -> Option<DispatchInterfaceType> {
    if let Ok(mut fd) = std::fs::File::open(file_path) {
        let mut content = String::new();
        fd.read_to_string(&mut content).ok();
        if !content.is_empty() {
            return nm_iface_dispatch_script_to_nmstate(
                file_name,
                content.as_str(),
            );
        }
    }
    None
}

fn get_lines_between<'a>(
    lines: &[&'a str],
    start_line: &str,
    end_line: &str,
) -> Vec<&'a str> {
    let mut ret: Vec<&str> = Vec::new();
    let mut started = false;
    for line in lines {
        if line.ends_with(end_line) {
            break;
        } else if started {
            ret.push(line);
        } else if line.ends_with(start_line) {
            started = true;
        }
    }
    ret
}

fn nm_iface_dispatch_script_to_nmstate(
    file_name: &str,
    content: &str,
) -> Option<DispatchInterfaceType> {
    if content.contains(SCRIPT_DISCLAMER) {
        let lines: Vec<&str> = content.split('\n').collect();

        let mut variables: Vec<String> = Vec::new();

        for line in get_lines_between(
            lines.as_slice(),
            SCRIPT_VARIABLE_START,
            SCRIPT_VARIABLE_END,
        )
        .as_slice()
        {
            if let Some(index) = line.find('=') {
                variables.push(line[..index].to_string());
            }
        }

        let mut kernel_index_getter: Option<String> = None;
        let mut activation = String::new();
        for line in get_lines_between(
            lines.as_slice(),
            SCRIPT_ACTIVATION_START,
            SCRIPT_ACTIVATION_END,
        )
        .as_slice()
        {
            if let Some(line) = line.strip_prefix(INDENT) {
                if let Some(line) = line.strip_prefix(KERNEL_INDEX_GETTER) {
                    // Remove trailing `)`
                    kernel_index_getter =
                        Some(line[..(line.len() - 1)].to_string());
                } else {
                    writeln!(activation, "{}", line).ok();
                }
            } else {
                writeln!(activation, "{}", line).ok();
            }
        }
        // Removing trailing '\n'
        activation.truncate(activation.len() - 1);

        let mut deactivation = String::new();
        for line in get_lines_between(
            lines.as_slice(),
            SCRIPT_DEACTIVATION_START,
            SCRIPT_DEACTIVATION_END,
        )
        .as_slice()
        {
            if let Some(line) = line.strip_prefix(INDENT) {
                writeln!(deactivation, "{}", line).ok();
            } else {
                writeln!(deactivation, "{}", line).ok();
            }
        }
        // Removing trailing '\n'
        deactivation.truncate(deactivation.len() - 1);

        Some(DispatchInterfaceType {
            kind: file_name.to_string(),
            activation: Some(activation),
            deactivation: Some(deactivation),
            kernel_index_getter,
            allowed_variable_names: Some(variables),
            ..Default::default()
        })
    } else {
        None
    }
}

fn gen_nm_dispatch_iface_handler_script(
    conf: &DispatchInterfaceType,
) -> String {
    let iface_type_name = conf.kind.as_str();
    let empty_str = String::new();
    let activation: Vec<&str> = conf
        .activation
        .as_deref()
        .unwrap_or(empty_str.as_str())
        .split('\n')
        .collect();
    let deactivation: Vec<&str> = conf
        .deactivation
        .as_deref()
        .unwrap_or(empty_str.as_str())
        .split('\n')
        .collect();

    let mut content = format!(
        "#!/usr/bin/env bash\n\
        {SCRIPT_DISCLAMER}\n\n\
        name=$1\n\
        action=$2\n\n"
    );

    writeln!(content, "{SCRIPT_VARIABLE_START}").ok();
    if let Some(variables) = conf.allowed_variable_names.as_deref() {
        for key in variables {
            writeln!(
                content,
                "{key}=$CONNECTION_USER_{}__{}",
                iface_type_name.to_uppercase(),
                key.to_uppercase()
            )
            .ok();
        }
    }
    writeln!(content, "{SCRIPT_VARIABLE_END}\n").ok();

    writeln!(content, "if [ \"$action\" = \"device-add\" ]; then").ok();
    writeln!(content, "{INDENT}{SCRIPT_ACTIVATION_START}").ok();
    for line in activation.as_slice() {
        writeln!(content, "{INDENT}{line}").ok();
    }

    if let Some(kernel_index_getter) = conf.kernel_index_getter.as_deref() {
        writeln!(
            content,
            "{INDENT}{KERNEL_INDEX_GETTER}{kernel_index_getter})",
        )
        .ok();
    }

    writeln!(content, "{INDENT}{SCRIPT_ACTIVATION_END}").ok();
    writeln!(content, "{INDENT}exit 0").ok();
    writeln!(content, "fi").ok();

    writeln!(content, "if [ \"$action\" = \"device-delete\" ]; then").ok();
    writeln!(content, "{INDENT}{SCRIPT_DEACTIVATION_START}").ok();
    for line in deactivation.as_slice() {
        writeln!(content, "{INDENT}{line}").ok();
    }
    writeln!(content, "{INDENT}{SCRIPT_DEACTIVATION_END}\nfi").ok();

    content
}
